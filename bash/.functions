#!/bin/bash

mkcd() {
    mkdir -p "$1"
    cd "$1" || return
 }

cdls() {
    cd "$1" || return
    ls
}

md5check () {
    md5sum "$1" | grep "$2"
}

sha256check () {
    sha256sum "$1" | grep "$2"
}

histg () {
    history | rg -i -e "$1"
}

extract() {
    if [ -f "$1" ] ; then
      case $1 in
        *.tar.bz2)   tar xjf "$1"     ;;
        *.tar.gz)    tar xzf "$1"     ;;
        *.bz2)       bunzip2 "$1"     ;;
        *.rar)       unrar e "$1"     ;;
        *.gz)        gunzip "$1"      ;;
        *.tar)       tar xf "$1"      ;;
        *.tbz2)      tar xjf "$1"     ;;
        *.tgz)       tar xzf "$1"     ;;
        *.zip)       unzip "$1"       ;;
        *.Z)         uncompress "$1"  ;;
        *.7z)        7z x "$1"        ;;
        *)     echo "$1 cannot be extracted via extract()" ;;
         esac
     else
         echo "$1 is not a valid file"
     fi
}

#   List all contents of current directory sorted by size
sbsall() {
        du -b --max-depth 1 | \
        sort -nr | \
        perl -pe 's{([0-9]+)}{sprintf "%.1f%s", $1>=2**30? ($1/2**30, "G"): $1>=2**20? ($1/2**20, "M"): $1>=2**10? ($1/2**10, "K"): ($1, "")}e';
}

#   List non-hidden directories of current directory sorted by size
sbs() { du -hsx ./* | sort -rh; }

up() {
    times=$1
    while [ "$times" -gt "0" ]; do
        cd ..
        # shellcheck disable=SC2004
        times=$(($times-1))
    done
}

# Make a temporary directory and enter it
mktmpcd() {
	local dir
	if [ $# -eq 0 ]; then
		dir=$(mktemp -d)
	else
		dir=$(mktemp -d -t "${1}.XXXXXXXXXX")
	fi
	cd "$dir" || exit
}

#   Enter a pre-existing tmp folder or create one
tmpcd() {
    shopt -s nullglob
    local tmps=( /tmp/tmp.* )
    #   If no tmp folders found $tmps will consist of pattern
    if [ "${#tmps[@]}" -eq 0 ]; then
        mktmpcd "$@"
    else
        cd "${tmps[0]}" || return
    fi
    shopt -u nullglob
}

# Compare original and gzipped file size
gz() {
	local origsize gzipsize ratio
	origsize=$(wc -c < "$1")
	gzipsize=$(gzip -c "$1" | wc -c)
    #   Calc is a bash function defined in this file
    ratio=$(calc "$gzipsize/$origsize*100")
	printf "orig: %d bytes\\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\\n" "$gzipsize" "$ratio"
}

# check if uri is up
isup() {
	local uri=$1

    [ "$#" -ne 1 ] && echo "Usage: ${FUNCNAME[0]} <URI>" && return 1

    #   If HTTP code not 200
    if curl -Ls -o /dev/null -w "%{http_code}" "$uri" | grep -v "200" > /dev/null; then
        return 1
    fi
}

# define word
def() {
    /usr/bin/firefox --new-tab -search "define $1"
}

# word synonym
syn() {
    /usr/bin/firefox --new-tab -search "synonym $1"
}

#   Create backup file
bak() { cp "$1"{,.bak};}

#   Crypto
shred_current_directory() {
    echo "You will IRREVERSIBLY shred the following files:"
    find . ! -path .
    read -p "Are you sure? (y/n): " -r
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
        echo "shredding..."
        find . -type f -exec shred {} -n 1 --remove=wipe \;
        echo "completed shredding."
    fi
}

launch_ssh_agent() {
    eval "$(ssh-agent -s)"
    ssh-add
}

# Get colors in manual pages
man() {
    env \
    LESS_TERMCAP_mb="$(printf '\e[1;31m')" \
    LESS_TERMCAP_md="$(printf '\e[1;31m')" \
    LESS_TERMCAP_me="$(printf '\e[0m')" \
    LESS_TERMCAP_se="$(printf '\e[0m')" \
    LESS_TERMCAP_so="$(printf '\e[1;44;33m')" \
    LESS_TERMCAP_ue="$(printf '\e[0m')" \
    LESS_TERMCAP_us="$(printf '\e[1;32m')" \
    man "$@"
}

restart_gpgagent(){
    # Restart the gpg agent.
    # shellcheck disable=SC2046
    kill -9 $(pidof scdaemon) >/dev/null 2>&1
    # shellcheck disable=SC2046
    kill -9 $(pidof gpg-agent) >/dev/null 2>&1
    gpg-connect-agent /bye >/dev/null 2>&1
    gpg-connect-agent updatestartuptty /bye >/dev/null 2>&1
}

#   randpw [--no-symbols,-n] [--clip,-c] [pass-length]
#       Generate password from /dev/urandom of <pass-length> (default 25).
#       optionally exclude symbols or pipe into clipboard.
randpw() {
    local length=25 clip=0 chars='A-Za-z0-9[:punct:]' pass
    while true; do case $1 in
        -n|--no-symbols) chars='A-Za-z0-9'; shift ;;
        -c|--clip) clip=1; shift ;;
        *[0-9]*) length="$1"; shift;;
        *) break;;
    esac done
    pass=$( LC_ALL=C </dev/urandom tr -dc "$chars" | head -c "${1:-$length}" )
    echo -n "$pass" | { if (( clip == 1 )); then xclip -selection clipboard; else cat -; fi; }
}

rename_snake() {
    # Credit:
    #   https://www.tecmint.com/rename-all-files-and-directory-names-to-lowercase-in-linux/
    if [ -z "$1" ];then
        >&2 echo "Usage: ${FUNCNAME[0]} <directory>"
        return 1
    fi

    #process all subdirectories and files in parent directory
    all="$(find "$1" -maxdepth 1)"

    IFS=$'\n'   #   only split on newline in case spaces in filename
    for name in ${all}; do
        #   set new name in lower case for files and directories
        new_name="$(dirname "${name}")/$(basename "${name}" | tr '[:upper:]' '[:lower:]')"
        #   replace spaces with tabs in new_name
        new_name="${new_name// /_}"

        #   check if new name already exists
        if [ "${name}" != "${new_name}" ]; then
            [ ! -e "${new_name}" ] && mv -T "${name}" "${new_name}"; echo "${name} was renamed to ${new_name}" || echo "${name} wasn't renamed!"
        fi
    done
    unset IFS
}

#   create .tar.gz and remove it if successful
#   basename takes care of trailing backslash in directory
targz() { tar -zcvf "$(basename "$1").tar.gz" "$1" && rm -r "$1"; }

#   extract tar.gz and remove it if successful
untargz() { tar -zxvf "$1" && rm -r "$1"; }

#   calculate
calc(){ awk "BEGIN { print ""$*"" }"; }


# ------------------------------------
# Docker functions
#   credit: https://github.com/tcnksm/docker-alias
# ------------------------------------

# Stop all containers
dstop() { docker stop "$(docker ps -a -q)"; }

# Remove all containers
drmall() { docker rm "$(docker ps -a -q)"; }

# Remove all images
drmiall() { docker images -q | xargs docker rmi -f; }

# Dockerfile build, e.g., $dbu tcnksm/test
dbu() { docker build -t "$1" .; }

# Show all alias related docker
dalias() { alias | grep 'docker' | sed "s/^\([^=]*\)=\(.*\)/\1 => \2/"| sed "s/['|\']//g" | sort; }

# Bash into running container
dbash() { docker exec -it "$(docker ps -aqf "name=$1")" bash; }
